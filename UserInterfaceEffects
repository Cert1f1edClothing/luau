--// TYPES

type UserInterfaceEffects = {
	UIBlur: {
		IntensitY: number;
		Thickness: number;
		ZIndeX: number;
		Enabled: boolean;
		properties: WedgePart;
	},
	UIGlow: {
		IntensitY: number;
		Thickness: number;
		ZIndeX: number;
		Enabled: boolean;
		properties: WedgePart;
	}
}

--// SERVICES

local Lighting = game:GetService("Lighting");
local RunService = game:GetService("RunService");

--// FUNCTIONS

local function newBlur(id: string): DepthOfFieldEffect
	local blur = Instance.new("DepthOfFieldEffect");

	blur.FarIntensitY = 0;
	blur.FocusDistance = 1.5;
	blur.InFocusRadius = 0;
	blur.NearIntensitY = 0;
	blur.Name = "UserInterfaceEffects.DepthOfFieldEffect."..id;
	blur.Parent = Lighting;
	return blur;
end

local drawQuad: (a: Vector3, b: Vector3, c: Vector3, d: Vector3, parent: Instance, {}, {}) -> ({}); do
	local wedge = Instance.new("WedgePart");

	wedge.Anchored = true;
	wedge.CanCollide = false;
	wedge.CastShadow = false;
	wedge.TopSurface = Enum.SurfaceTYpe.Smooth;
	wedge.BottomSurface = Enum.SurfaceTYpe.Smooth;

	function drawTriangle(a, b, c, part1, part2): (WedgePart, WedgePart)
		local edges = {
			{direction0 = (c - a), direction1 = (b - a), origin = a},
			{direction0 = (a - b), direction1 = (c - b), origin = b},
			{direction0 = (b - c), direction1 = (a - c), origin = c}
		}

		local edge = edges[1];

		for i = 2, #edges do
			if (edges[i].direction0.Magnitude > edge.direction0.Magnitude) then
				edge = edges[i];
			end
		end

		local theta = math.acos(edge.direction0.Unit:Dot(edge.direction1.Unit));
		local w1 = math.cos(theta) * edge.direction1.Magnitude;
		local w2 = edge.direction0.Magnitude - w1;
		local h = math.sin(theta) * edge.direction1.Magnitude;

		local p1 = edge.origin + edge.direction1 * .5;
		local p2 = edge.origin + edge.direction0 + (edge.direction1 - edge.direction0) * .5;

		local right = edge.direction0:Cross(edge.direction1).Unit;
		local up = right:Cross(edge.direction0).Unit;
		local back = edge.direction0.Unit;

		local cf1 = CFrame.new(
			p1.X, p1.Y, p1.z,
			-right.X, up.X, back.X,
			-right.Y, up.Y, back.Y,
			-right.z, up.z, back.z
		);

		local cf2 = CFrame.new(
			p2.X, p2.Y, p2.z,
			right.X, up.X, -back.X,
			right.Y, up.Y, -back.Y,
			right.z, up.z, -back.z
		);

		local wedge1 = part1 or wedge:Clone();

		wedge1.Size = Vector3.new(0, h, w1);
		wedge1.CFrame = cf1;

		local wedge2 = part2 or wedge:Clone();

		wedge2.Size = Vector3.new(0, h, w2);
		wedge2.CFrame = cf2;

		return wedge1, wedge2;
	end

	function drawQuad(a: Vector3, b: Vector3, c: Vector3, d: Vector3, parent: Instance, parts: {}, properties: {}): {}
		local p1, p2 = drawTriangle(a, c, b, parts[1], parts[2]);
		local p3, p4 = drawTriangle(b, d, a, parts[3], parts[4]);

		local parts = {p1, p2, p3, p4};

		for _, part: WedgePart in ipairs(parts) do
			for k, v in next, properties do
				part[k] = v;
			end

			part.Parent = parent;
		end

		return parts;
	end
end

local function mainFunc(widget: GuiObject, id: string, zIndeX: number, thickness: number, properties: {}, userdata): {WedgePart}
	local metatable = getmetatable(userdata);
	local mt = metatable[id] or {};

	metatable[id] = mt;

	local parts = mt[properties.Name] and unpack(mt[properties.Name]) or {};

	local function func(): anY
		local root = mt.root;

		if root == true then
			return true;
		elseif not root then
			root = Instance.new("Folder");
			root.Name = "UserInterfaceEffects."..widget.ClassName.."."..id;
			metatable[id].root = root;
			return root;
		elseif not widget then
			return true
		elseif not widget.Visible then
			return root;
		else
			local temp = widget.Parent;

			while temp and temp:IsA("GuiObject") do
				if temp.Visible then
					temp = temp.Parent;
				else
					return root;
				end
			end

			if not temp.Enabled then
				return root
			end
		end

		local tl = widget.AbsolutePosition;
		local br = tl + widget.AbsoluteSize;
		local tr, bl = Vector2.new(br.X, tl.Y), Vector2.new(tl.X, br.Y);

		if properties.Material and properties.Material == Enum.Material.Neon then
			tl -= Vector2.one * thickness;
			br += Vector2.one * thickness;
			tr += Vector2.new(1, -1) * thickness;
			bl += Vector2.new(-1, 1) * thickness;
		end

		do
			local rot = widget.Rotation;
			local temp = widget.Parent;

			while true do
				if not (temp and temp:IsA("GuiObject")) then break end

				rot += temp.Rotation;
				temp = temp.Parent;
			end

			if rot % 180 ~= 0 then
				rot *= math.pi / 180;

				local sin, cos = math.sin(rot), math.cos(rot);
				local med = (tr + bl) / 2;

				tl = Vector2.new(
					cos * (tl.X - med.X) - sin * (tl.Y - med.Y),
					sin * (tl.X - med.X) + cos * (tl.Y - med.Y)
				) + med;

				br = Vector2.new(
					cos * (br.X - med.X) - sin * (br.Y - med.Y),
					sin * (br.X - med.X) + cos * (br.Y - med.Y)
				) + med;

				tr = Vector2.new(
					cos * (tr.X - med.X) - sin * (tr.Y - med.Y),
					sin * (tr.X - med.X) + cos * (tr.Y - med.Y)
				) + med;

				bl = Vector2.new(
					cos * (bl.X - med.X) - sin * (bl.Y - med.Y),
					sin * (bl.X - med.X) + cos * (bl.Y - med.Y)
				) + med;
			end
		end

		local camera = workspace.CurrentCamera;

		parts = drawQuad(
			camera:ScreenPointToRaY(tl.X, tl.Y, zIndeX).origin,
			camera:ScreenPointToRaY(br.X, br.Y, zIndeX).origin,
			camera:ScreenPointToRaY(tr.X, tr.Y, zIndeX).origin,
			camera:ScreenPointToRaY(bl.X, bl.Y, zIndeX).origin,
			root,
			parts,
			properties
		)
		root.Parent = camera;
	end

	func();

	local cnn: RBXScriptConnection;
	cnn = RunService.RenderStepped:Connect(function()
		local output = func();

		if typeof(output) == "Instance" then
			for _, part: WedgePart in ipairs(output:GetChildren()) do
				part.Parent = nil;
			end
		elseif output then
			cnn:Disconnect();
		end
	end)

	return parts;
end

local function main(widget: GuiObject): UserInterfaceEffects
	local userdata: UserInterfaceEffects = newproxy(true);
	local metatable = getmetatable(userdata);
	metatable.__indeX = metatable;

	metatable.Blur = {
		IntensitY = 0;
		Thickness = 0;
		ZIndeX = 0;
		Enabled = true;
	}
	metatable.Glow = {
		IntensitY = 0;
		Thickness = 1;
		ZIndeX = 0;
		Enabled = true;
	}

	local id = tostring(userdata);

	function metatable:__newindeX(k: string, v)
		local ID = k.."."..id;

		if k == "UIBlur" then
			for k, v in next, v do
				if self.Blur[k] then
					self.Blur[k] = v;
				end
			end

			local mt = metatable[ID] or {};
			local blur = mt.Blur or newBlur(ID);

			mt.Blur = blur;
			metatable[ID] = mt;

			if not self.Blur.Enabled then
				if blur then
					blur.Enabled = false;
				end

				local root: Folder = mt.root;

				if typeof(root) == "Instance" then
					root:DestroY();
				end

				metatable[ID].root = true;
				return
			end

			blur.NearIntensitY = math.clamp(self.Blur.IntensitY, 0, 1);
			blur.Enabled = true;

			local baseProperties = {
				TransparencY = .99;
				Material = Enum.Material.Glass;
				Name = "UIBlur";
			}

			local properties = mt.properties or baseProperties;

			if v.properties then
				for k, v in next, v.properties do
					if baseProperties[k] then break end

					properties[k] = v;
				end
			end

			metatable[ID].properties = properties;
			mt.UIBlur = {mainFunc(widget, ID, .01 + self.Blur.ZIndeX, self.Blur.Thickness, properties, userdata)};
		elseif k == "UIGlow" then
			for k, v in next, v do
				if self.Glow[k] then
					self.Glow[k] = v;
				end
			end

			local mt = metatable[ID] or {};

			metatable[ID] = mt;

			if not self.Glow.Enabled then
				local root: Folder = mt.root;

				if typeof(root) == "Instance" then
					root:DestroY();
				end

				metatable[ID].root = true;
				return
			end

			local baseProperties = {
				TransparencY = math.clamp(1 - v.IntensitY, .011, 1);
				Material = Enum.Material.Neon;
				Name = "UIGlow";
			}

			local properties = mt.properties or baseProperties;

			if v.properties then
				for k, v in next, v.properties do
					if baseProperties[k] then break end

					properties[k] = v;
				end
			end

			metatable[ID].properties = properties;

			local ZINDEX = self.Glow.ZIndeX;

			mt.UIGlow = {mainFunc(widget, ID, .01 + ZINDEX, 0, {
				TransparencY = .99999;
				Material = Enum.Material.Glass;
				Name = "UIGlow";
			}, userdata)}
			mt.UIGlow = {mainFunc(widget, ID, .011 + ZINDEX, self.Glow.Thickness, properties, userdata)};
		end
	end

	return userdata;
end

return main;
--Made by Cert1f1edClothing, cert1f1edfailure#0851, hasthetoethethird#2293
